name: Build Multi-Platform and Create Pre-Release

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Pre-release version (e.g., v0.0.5-alpha.1)'
        required: true
        default: 'v0.0.5-alpha.1'
      prerelease:
        description: 'Mark as pre-release'
        required: true
        default: true
        type: boolean
      release_notes:
        description: 'Custom release notes (optional)'
        required: false
        default: ''

permissions:
  contents: write

jobs:
  discover-programs:
    runs-on: ubuntu-latest
    outputs:
      programs: ${{ steps.discover.outputs.programs }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Discover parser programs
      id: discover
      run: |
        # Define all parser base directories
        PARSER_BASE_DIRS=(
          "src/SwitchOutput/Cisco/Nexus/10"
          "src/SwitchOutput/DellOS/10"
        )
        
        echo "Looking for parsers in multiple directories..."
        
        # Build JSON array of programs
        PROGRAM_ARRAY="["
        FIRST=true
        
        for PARSER_BASE_DIR in "${PARSER_BASE_DIRS[@]}"; do
          echo ""
          echo "Checking directory: $PARSER_BASE_DIR"
          
          if [ ! -d "$PARSER_BASE_DIR" ]; then
            echo "WARNING: Directory $PARSER_BASE_DIR not found, skipping..."
            continue
          fi
          
          # Find all *_parser directories
          PARSER_DIRS=$(find "$PARSER_BASE_DIR" -maxdepth 1 -name "*_parser" -type d | sort)
          
          if [ -z "$PARSER_DIRS" ]; then
            echo "No parser directories found in $PARSER_BASE_DIR"
            continue
          fi
          
          echo "Found parser directories in $PARSER_BASE_DIR:"
          for dir in $PARSER_DIRS; do
            echo "  - $dir"
          done
          
          for parser_dir in $PARSER_DIRS; do
            parser_name=$(basename "$parser_dir")
            parser_go_file="$parser_dir/$parser_name.go"
            
            # Extract vendor info from path
            if [[ "$parser_dir" == *"Cisco"* ]]; then
              vendor="cisco"
            elif [[ "$parser_dir" == *"DellOS"* ]]; then
              vendor="dell"
            else
              vendor="unknown"
            fi
            
            echo "Checking for: $parser_go_file"
            
            if [ -f "$parser_go_file" ]; then
              if grep -q "package main" "$parser_go_file"; then
                echo "  ✓ Found valid main program: $parser_name ($vendor)"
                
                if [ "$FIRST" = true ]; then
                  FIRST=false
                else
                  PROGRAM_ARRAY+=","
                fi
                
                PROGRAM_ARRAY+="{\"name\":\"$parser_name\",\"dir\":\"$parser_dir\",\"file\":\"$parser_go_file\",\"vendor\":\"$vendor\"}"
              else
                echo "  ✗ $parser_go_file does not have 'package main'"
              fi
            else
              echo "  ✗ $parser_go_file not found"
            fi
          done
        done
        
        PROGRAM_ARRAY+="]"
        
        echo "programs=$PROGRAM_ARRAY" >> $GITHUB_OUTPUT
        echo ""
        echo "Final programs JSON:"
        echo "$PROGRAM_ARRAY" | jq -r '.[] | "  - \(.vendor)/\(.name) (\(.dir))"'
        
        # Validate we found at least one program
        PROGRAM_COUNT=$(echo "$PROGRAM_ARRAY" | jq length)
        if [ "$PROGRAM_COUNT" -eq 0 ]; then
          echo "ERROR: No valid programs discovered!"
          exit 1
        fi
        
        echo "Successfully discovered $PROGRAM_COUNT parser programs across all vendors"

  build:
    needs: discover-programs
    runs-on: ubuntu-latest
    strategy:
      matrix:
        platform:
          - goos: linux
            goarch: amd64
            name: linux-amd64
          - goos: windows
            goarch: amd64
            name: windows-amd64
            ext: .exe
        program: ${{ fromJson(needs.discover-programs.outputs.programs) }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.21'
        
    - name: Build binary
      run: |
        cd "${{ matrix.program.dir }}"
        
        echo "Building ${{ matrix.program.vendor }}/${{ matrix.program.name }} for ${{ matrix.platform.goos }}/${{ matrix.platform.goarch }}"
        echo "Working directory: $(pwd)"
        echo "Source file: ${{ matrix.program.name }}.go"
        
        # List directory contents for debugging
        echo "Directory contents:"
        ls -la
        
        # Check if source file exists
        if [ ! -f "${{ matrix.program.name }}.go" ]; then
          echo "ERROR: Source file ${{ matrix.program.name }}.go not found!"
          exit 1
        fi
        
        # Initialize go module if it doesn't exist
        if [ ! -f "go.mod" ]; then
          echo "Initializing go module for ${{ matrix.program.name }}..."
          go mod init "${{ matrix.program.name }}"
        fi
        
        # Tidy dependencies
        go mod tidy
        
        # Build the binary
        CGO_ENABLED=0 GOOS=${{ matrix.platform.goos }} GOARCH=${{ matrix.platform.goarch }} \
          go build -ldflags="-w -s" -o "${{ matrix.program.name }}${{ matrix.platform.ext }}" "${{ matrix.program.name }}.go"
        
        echo "Build successful!"
        ls -la "${{ matrix.program.name }}${{ matrix.platform.ext }}"
          
    - name: Package binary
      run: |
        cd "${{ matrix.program.dir }}"
        mkdir -p $GITHUB_WORKSPACE/release-assets
        
        # Determine what files to include
        PACKAGE_FILES="${{ matrix.program.name }}${{ matrix.platform.ext }}"
        
        # Always include README if it exists
        if [ -f "README.md" ]; then
          PACKAGE_FILES="$PACKAGE_FILES README.md"
        fi
        
        # Include common files from the parent directory
        PARENT_DIR=".."  # Go up one level from parser directory
        
        # Check for commands.json in parent directory
        if [ -f "$PARENT_DIR/commands.json" ]; then
          cp "$PARENT_DIR/commands.json" .
          PACKAGE_FILES="$PACKAGE_FILES commands.json"
        fi
        
        # Include any sample files or documentation in the current directory
        for file in *.json *.txt; do
          if [ -f "$file" ] && [[ "$file" != "${{ matrix.program.name }}${{ matrix.platform.ext }}" ]]; then
            PACKAGE_FILES="$PACKAGE_FILES $file"
          fi
        done
        
        echo "Packaging files: $PACKAGE_FILES"
        
        # Create archive with vendor prefix in filename
        ARCHIVE_NAME="${{ matrix.program.vendor }}-${{ matrix.program.name }}-${{ github.event.inputs.version }}-${{ matrix.platform.name }}"
        
        if [ "${{ matrix.platform.goos }}" = "windows" ]; then
          zip "$GITHUB_WORKSPACE/release-assets/${ARCHIVE_NAME}.zip" $PACKAGE_FILES
        else
          tar -czf "$GITHUB_WORKSPACE/release-assets/${ARCHIVE_NAME}.tar.gz" $PACKAGE_FILES
        fi
        
    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ matrix.program.vendor }}-${{ matrix.program.name }}-${{ matrix.platform.name }}
        path: release-assets/

  create-release:
    needs: [discover-programs, build]
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts
        
    - name: Prepare release assets
      run: |
        mkdir -p release-assets
        find artifacts -name "*-${{ github.event.inputs.version }}-*" -type f -exec cp {} release-assets/ \;
        
        echo "Release assets prepared:"
        ls -la release-assets/
        
    - name: Generate checksums
      run: |
        cd release-assets
        echo "Generating checksums..."
        for archive in *; do
          echo "  Generating checksum for $archive"
          sha256sum "$archive" > "${archive}.sha256"
        done
        echo "All checksums generated"
        
    - name: Get previous tag
      id: prev_tag
      run: |
        PREV_TAG=$(git tag --sort=-version:refname | head -n1 2>/dev/null || echo "")
        echo "prev_tag=${PREV_TAG}" >> $GITHUB_OUTPUT
        
    - name: Create Git Tag
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag -a "${{ github.event.inputs.version }}" -m "Release ${{ github.event.inputs.version }}"
        git push origin "${{ github.event.inputs.version }}"
        
    - name: Generate release notes
      id: release_notes
      run: |
        # Parse programs by vendor
        CISCO_PARSERS=$(echo '${{ needs.discover-programs.outputs.programs }}' | jq -r '[.[] | select(.vendor == "cisco")] | .[] | "- **" + .name + "**"' | tr '\n' '\n')
        DELL_PARSERS=$(echo '${{ needs.discover-programs.outputs.programs }}' | jq -r '[.[] | select(.vendor == "dell")] | .[] | "- **" + .name + "**"' | tr '\n' '\n')
        
        cat > release_notes.md << EOF
        # Switch Output Parsers - ${{ github.event.inputs.version }}
        
        Multi-platform binaries for network switch output parsing tools.
        
        ## Available Parsers
        
        ### Cisco Nexus Parsers
        $CISCO_PARSERS
        
        ### Dell OS10 Parsers  
        $DELL_PARSERS
        
        ## Platforms
        - **Linux AMD64** (\`.tar.gz\`)
        - **Windows AMD64** (\`.zip\`)
        
        ## Usage
        \`\`\`bash
        # Linux example (Cisco parser)
        tar -xzf cisco-class_map_parser-${{ github.event.inputs.version }}-linux-amd64.tar.gz
        ./class_map_parser -input show-class-map.txt -output output.json
        
        # Windows example (Dell parser)
        # Extract the .zip file and run the .exe
        dell-interface_parser.exe -input show-interface.txt -output output.json
        \`\`\`
        
        ## File Naming Convention
        Files are prefixed with vendor name for clarity:
        - \`cisco-<parser_name>-<version>-<platform>.<ext>\`
        - \`dell-<parser_name>-<version>-<platform>.<ext>\`
        EOF
        
        # Output for next step
        echo "notes_file=release_notes.md" >> $GITHUB_OUTPUT

    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ github.event.inputs.version }}
        name: Release ${{ github.event.inputs.version }}
        body_path: ${{ steps.release_notes.outputs.notes_file }}
        prerelease: ${{ github.event.inputs.prerelease }}
        files: release-assets/*
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Print release summary
      run: |
        PROGRAM_COUNT=$(echo '${{ needs.discover-programs.outputs.programs }}' | jq length)
        CISCO_COUNT=$(echo '${{ needs.discover-programs.outputs.programs }}' | jq '[.[] | select(.vendor == "cisco")] | length')
        DELL_COUNT=$(echo '${{ needs.discover-programs.outputs.programs }}' | jq '[.[] | select(.vendor == "dell")] | length')
        PLATFORM_COUNT=2
        TOTAL_BINARIES=$((PROGRAM_COUNT * PLATFORM_COUNT))
        
        echo "Release created successfully!"
        echo "Tag: ${{ github.event.inputs.version }}"
        echo "Total programs built: $PROGRAM_COUNT"
        echo "  - Cisco parsers: $CISCO_COUNT"
        echo "  - Dell parsers: $DELL_COUNT"
        echo "Platforms: $PLATFORM_COUNT (Linux, Windows)"
        echo "Total binary packages: $TOTAL_BINARIES"
        echo ""
        echo "Assets:"
        ls -la release-assets/
        echo ""
        echo "Release URL: https://github.com/${{ github.repository }}/releases/tag/${{ github.event.inputs.version }}"